//+------------------------------------------------------------------+
//| Expert Advisor: ThreeCandlesEA Inverted + Pivot + SL Reverse     |
//+------------------------------------------------------------------+
#property strict

#include <Trade/Trade.mqh>
CTrade trade;

input double RiskPerTrade    = 1000;   
input int    ATR_Period      = 14;
input double MinBodyPercent  = 0.80;   
input double MoveATRFactor   = 3.0;    
input double SLTP_Multiplier = 2.0;    

int atrHandle;
datetime lastTradeBar = 0;

// Ø°Ø®ÛŒØ±Ù‡ Ø¢Ø®Ø±ÛŒÙ† Ù…Ø¹Ø§Ù…Ù„Ù‡
string lastDirection = "";
double lastLots = 0;

//--------------------------------------------------------------------
int OnInit()
{
   atrHandle = iATR(_Symbol, _Period, ATR_Period);
   if(atrHandle == INVALID_HANDLE)
   {
      Print("Error creating ATR handle");
      return(INIT_FAILED);
   }
   return(INIT_SUCCEEDED);
}
void OnDeinit(const int reason)
{
   if(atrHandle != INVALID_HANDLE)
      IndicatorRelease(atrHandle);
}

//--------------------------------------------------------------------
// ØªÙˆØ§Ø¨Ø¹ Ú©Ù…Ú©ÛŒ (Ù‡Ù…ÙˆÙ† Ù‚Ø¨Ù„ÛŒ)
bool isBullish(int i) { return (iClose(_Symbol,_Period,i) > iOpen(_Symbol,_Period,i)); }
bool isBearish(int i) { return (iClose(_Symbol,_Period,i) < iOpen(_Symbol,_Period,i)); }
bool isValidCandle(int i) { double h=iHigh(_Symbol,_Period,i), l=iLow(_Symbol,_Period,i), o=iOpen(_Symbol,_Period,i), c=iClose(_Symbol,_Period,i); double total=h-l; if(total<=0) return false; double body=MathAbs(c-o); return (body/total >= MinBodyPercent); }

void GetDailyPivots(double &pivot, double &r1, double &s1, double &r2, double &s2, double &r3, double &s3)
{
   double highPrev  = iHigh(_Symbol, PERIOD_D1, 1);
   double lowPrev   = iLow(_Symbol, PERIOD_D1, 1);
   double closePrev = iClose(_Symbol, PERIOD_D1, 1);
   pivot = (highPrev + lowPrev + closePrev) / 3.0;
   r1 = 2*pivot - lowPrev; s1 = 2*pivot - highPrev;
   r2 = pivot + (highPrev - lowPrev); s2 = pivot - (highPrev - lowPrev);
   r3 = highPrev + 2*(pivot - lowPrev); s3 = lowPrev - 2*(highPrev - pivot);
}

void CreateLine(string name, double price, color clr) { if(ObjectFind(0,name) == -1) ObjectCreate(0, name, OBJ_HLINE, 0, 0, price); ObjectSetDouble(0,name,OBJPROP_PRICE,price); ObjectSetInteger(0,name,OBJPROP_COLOR,clr); ObjectSetInteger(0,name,OBJPROP_STYLE,STYLE_DOT); }

void DrawDailyPivots(double pivot,double r1,double s1,double r2,double s2,double r3,double s3)
{ string prefix="DailyPivot_"; CreateLine(prefix+"Pivot",pivot,clrYellow); CreateLine(prefix+"R1",r1,clrRed); CreateLine(prefix+"S1",s1,clrRed); CreateLine(prefix+"R2",r2,clrBlue); CreateLine(prefix+"S2",s2,clrBlue); CreateLine(prefix+"R3",r3,clrGreen); CreateLine(prefix+"S3",s3,clrGreen); }

bool TouchedPivot(int i,double pivot,double r1,double s1,double r2,double s2,double r3,double s3)
{ double high=iHigh(_Symbol,_Period,i), low=iLow(_Symbol,_Period,i); if((low<=pivot&&high>=pivot)||(low<=r1&&high>=r1)||(low<=s1&&high>=s1)||(low<=r2&&high>=r2)||(low<=s2&&high>=s2)||(low<=r3&&high>=r3)||(low<=s3&&high>=s3)) return true; return false; }

double CalculateLot(double stopDistance)
{
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   if(tickValue<=0||tickSize<=0) return(0);
   double riskPerLot = stopDistance/tickSize*tickValue;
   double lots = RiskPerTrade / riskPerLot;
   double minLot=SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MIN);
   double maxLot=SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_MAX);
   double step=SymbolInfoDouble(_Symbol,SYMBOL_VOLUME_STEP);
   lots=MathMax(minLot,MathMin(maxLot,lots));
   lots=MathFloor(lots/step)*step;
   return lots;
}

//--------------------------------------------------------------------
void OnTick()
{
   datetime currentBarTime = iTime(_Symbol, _Period, 0);
   if(currentBarTime == lastTradeBar) return;

   double atr[]; if(CopyBuffer(atrHandle,0,0,1,atr)<=0) return; double atrCurrent=atr[0];
   bool bull=(isBullish(3)&&isBullish(2)&&isBullish(1)&&isValidCandle(3)&&isValidCandle(2)&&isValidCandle(1));
   bool bear=(isBearish(3)&&isBearish(2)&&isBearish(1)&&isValidCandle(3)&&isValidCandle(2)&&isValidCandle(1));
   double totalMoveBull=iHigh(_Symbol,_Period,1)-iLow(_Symbol,_Period,3);
   double totalMoveBear=iHigh(_Symbol,_Period,3)-iLow(_Symbol,_Period,1);

   double pivot,r1,s1,r2,s2,r3,s3; GetDailyPivots(pivot,r1,s1,r2,s2,r3,s3); DrawDailyPivots(pivot,r1,s1,r2,s2,r3,s3);

   // ðŸ”„ Ù…Ø¹Ú©ÙˆØ³
   if (bull && iClose(_Symbol,_Period,1) > iHigh(_Symbol,_Period,2) && totalMoveBull >= MoveATRFactor*atrCurrent && TouchedPivot(1,pivot,r1,s1,r2,s2,r3,s3))
   {
      double price=SymbolInfoDouble(_Symbol,SYMBOL_BID); double sl=price+SLTP_Multiplier*atrCurrent; double tp=price-SLTP_Multiplier*atrCurrent;
      double lots=CalculateLot(sl-price);
      if(lots>0 && trade.Sell(lots,_Symbol,price,sl,tp,"Inverted Sell - Bullish + Pivot"))
      { lastTradeBar=currentBarTime; lastDirection="SELL"; lastLots=lots; }
   }

   if (bear && iClose(_Symbol,_Period,1) < iLow(_Symbol,_Period,2) && totalMoveBear >= MoveATRFactor*atrCurrent && TouchedPivot(1,pivot,r1,s1,r2,s2,r3,s3))
   {
      double price=SymbolInfoDouble(_Symbol,SYMBOL_ASK); double sl=price-SLTP_Multiplier*atrCurrent; double tp=price+SLTP_Multiplier*atrCurrent;
      double lots=CalculateLot(price-sl);
      if(lots>0 && trade.Buy(lots,_Symbol,price,sl,tp,"Inverted Buy - Bearish + Pivot"))
      { lastTradeBar=currentBarTime; lastDirection="BUY"; lastLots=lots; }
   }
}

//--------------------------------------------------------------------
// Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§Øª Ø¨Ø³ØªÙ‡â€ŒØ´Ø¯Ù‡ (Ø¨Ø±Ø§ÛŒ ØªØ´Ø®ÛŒØµ Ø§Ø³ØªØ§Ù¾â€ŒÙ„Ø§Ø³)
void OnTradeTransaction(const MqlTradeTransaction &trans,const MqlTradeRequest &request,const MqlTradeResult &result)
{
   if(trans.type==TRADE_TRANSACTION_DEAL_ADD)
   {
      ulong deal=trans.deal;
      if(HistoryDealSelect(deal))
      {
         long reason=HistoryDealGetInteger(deal,DEAL_REASON);
         long entry =HistoryDealGetInteger(deal,DEAL_ENTRY);
         double volume=HistoryDealGetDouble(deal,DEAL_VOLUME);
         string sym=HistoryDealGetString(deal,DEAL_SYMBOL);

         // Ø§Ú¯Ø± Ø§Ø³ØªØ§Ù¾ Ø®ÙˆØ±Ø¯
         if(reason==DEAL_REASON_SL && sym==_Symbol)
         {
            if(lastDirection=="BUY")
            {
               double price=SymbolInfoDouble(_Symbol,SYMBOL_BID);
               double atrCurrent[];
               if(CopyBuffer(atrHandle,0,0,1,atrCurrent)>0)
               {
                  double atr=atrCurrent[0];
                  double sl=price+SLTP_Multiplier*atr;
                  double tp=price-SLTP_Multiplier*atr;
                  trade.Sell(lastLots*2,_Symbol,price,sl,tp,"Reverse after SL");
               }
            }
            else if(lastDirection=="SELL")
            {
               double price=SymbolInfoDouble(_Symbol,SYMBOL_ASK);
               double atrCurrent[];
               if(CopyBuffer(atrHandle,0,0,1,atrCurrent)>0)
               {
                  double atr=atrCurrent[0];
                  double sl=price-SLTP_Multiplier*atr;
                  double tp=price+SLTP_Multiplier*atr;
                  trade.Buy(lastLots*2,_Symbol,price,sl,tp,"Reverse after SL");
               }
            }
         }
      }
   }
}
